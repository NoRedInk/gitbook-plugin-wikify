'use strict';
const path = require('path');
const Promise = require('bluebird');
const glob = Promise.promisify(require('glob'));

const DirectoryIndex = require('./directory_index');
const PageIndex = require('./page_index');
const Page = require('./page');
const Directory = require('./directory');
const open = require('./asyncfs').open;
const fs = require('./asyncfs').fs;


class Wiki {
  constructor (root, pageIndex, directoryIndex) {
    this.root = root;
    this.pageIndex = pageIndex;
    this.directoryIndex = directoryIndex;
  }

  static index(root, isFileIgnored) {
    const pageIndex = new PageIndex();
    const directoryIndex = new DirectoryIndex();
    const globOptions = {
      cwd: root,
      ignore: ['node_modules/**/*.md', 'SUMMARY.md', '**/' + Directory.indexPageName]
    };

    return glob('**/*.md', globOptions)
      .then(files => {
        files.forEach(filepath => {
          if (typeof isFileIgnored === 'function' && isFileIgnored(filepath)) {
            return;
          }

          const page = new Page(filepath, filepath);

          PageIndex.addPage(pageIndex, page);
          DirectoryIndex.addPage(directoryIndex, page);
          DirectoryIndex.parents(page.path).forEach(function(dir) {
            PageIndex.addPage(pageIndex, new Page(dir.indexPagePath, dir.path));
          });
        });
        return new Wiki(root, pageIndex, directoryIndex);
      });
  }

  /* generate dirname/README.md for all known directories */
  static generateIndexPages(wiki) {
    return Promise.all(
      Object.keys(wiki.directoryIndex).map(function(dirPath) {
        const resolvedDir = path.join(wiki.root, dirPath),
              indexFile = path.join(resolvedDir, Directory.indexPageName);
        return fs.accessAsync(indexFile, 'r')
          .catch(() => {
            // autogenerate an index
            return Wiki.generateIndexPage(wiki, wiki.directoryIndex[dirPath], indexFile);
          });
      }))
      .then(() => {
        return wiki;
      });
  }

  /* generate dirname/_index.md for a specific directory */
  static generateIndexPage(wiki, forDirectory, resolvedIndexPath) {
    return Promise.using(open(resolvedIndexPath, 'w'), fd => {
      // frontmatter and title
      const intro = '---\nautogenerated: true\n---\n\n# ' + forDirectory.path + '\n'
      return fs.writeAsync(fd, intro)
          .then(() => {
            // directories
            return Array.from(forDirectory.dirs).sort().reduce(function(promise, basename) {
              return promise.then(() => {
                return fs.writeAsync(
                  fd,
                  '- [' + basename + '](./' + basename + '/' + Directory.indexPageName + ')\n');
              });
            }, Promise.resolve());
          })
          .then(() => {
            // pages
            return Array.from(forDirectory.pages).sort().reduce(function(promise, basename) {
              return promise.then(() => {
                return fs.writeAsync(fd, '- [' + basename + '](./' + basename + ')\n');
              });
            }, Promise.resolve());
          });
    })
      .then(() => {
        return wiki;
      });
  }

  /* generate SUMMARY.md */
  static generateSummaryPage(wiki) {
    return Promise.using(open(path.resolve(wiki.root, 'SUMMARY.md'), 'w'), fd => {
      const titlePromise = fs.writeAsync(fd, '# Index\n');
      return PageIndex.sortedInitials(wiki.pageIndex)
          .reduce((promise, initial) => {
            const initialPromise = promise.then(() => {
              return fs.writeAsync(fd, '\n### ' + initial + '\n');
            });
            return PageIndex.sortPagesAt(wiki.pageIndex, initial)
              .reduce((promise, page) => {
                return promise.then(() => {
                  return fs.writeAsync(fd, '- [' + page.title + '](' + page.path + ')\n');
                });
              }, initialPromise);
          }, titlePromise);
    })
      .then(() => {
        return wiki;
      });
  }
}

module.exports = Wiki;
